function ZSWAP32(e){return(e>>>24&255)+(e>>>8&65280)+((e&65280)<<8)+((e&255)<<24)}function InflateState(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new utils.Buf16(320),this.work=new utils.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function inflateResetKeep(e){var t;return!e||!e.state?Z_STREAM_ERROR:(t=e.state,e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=t.wrap&1),t.mode=HEAD,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new utils.Buf32(ENOUGH_LENS),t.distcode=t.distdyn=new utils.Buf32(ENOUGH_DISTS),t.sane=1,t.back=-1,Z_OK)}function inflateReset(e){var t;return!e||!e.state?Z_STREAM_ERROR:(t=e.state,t.wsize=0,t.whave=0,t.wnext=0,inflateResetKeep(e))}function inflateReset2(e,t){var n,r;return!e||!e.state?Z_STREAM_ERROR:(r=e.state,t<0?(n=0,t=-t):(n=(t>>4)+1,t<48&&(t&=15)),t&&(t<8||t>15)?Z_STREAM_ERROR:(r.window!==null&&r.wbits!==t&&(r.window=null),r.wrap=n,r.wbits=t,inflateReset(e)))}function inflateInit2(e,t){var n,r;return e?(r=new InflateState,e.state=r,r.window=null,n=inflateReset2(e,t),n!==Z_OK&&(e.state=null),n):Z_STREAM_ERROR}function inflateInit(e){return inflateInit2(e,DEF_WBITS)}function fixedtables(e){if(virgin){var t;lenfix=new utils.Buf32(512),distfix=new utils.Buf32(32),t=0;while(t<144)e.lens[t++]=8;while(t<256)e.lens[t++]=9;while(t<280)e.lens[t++]=7;while(t<288)e.lens[t++]=8;inflate_table(LENS,e.lens,0,288,lenfix,0,e.work,{bits:9}),t=0;while(t<32)e.lens[t++]=5;inflate_table(DISTS,e.lens,0,32,distfix,0,e.work,{bits:5}),virgin=!1}e.lencode=lenfix,e.lenbits=9,e.distcode=distfix,e.distbits=5}function updatewindow(e,t,n,r){var i,s=e.state;return s.window===null&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new utils.Buf8(s.wsize)),r>=s.wsize?(utils.arraySet(s.window,t,n-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):(i=s.wsize-s.wnext,i>r&&(i=r),utils.arraySet(s.window,t,n-r,i,s.wnext),r-=i,r?(utils.arraySet(s.window,t,n-r,r,0),s.wnext=r,s.whave=s.wsize):(s.wnext+=i,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=i))),0}function inflate(e,t){var n,r,i,s,o,u,a,f,l,c,h,p,d,v,m=0,g,y,b,w,E,S,x,T,N=new utils.Buf8(4),C,k,L=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!e||!e.state||!e.output||!e.input&&e.avail_in!==0)return Z_STREAM_ERROR;n=e.state,n.mode===TYPE&&(n.mode=TYPEDO),o=e.next_out,i=e.output,a=e.avail_out,s=e.next_in,r=e.input,u=e.avail_in,f=n.hold,l=n.bits,c=u,h=a,T=Z_OK;e:for(;;)switch(n.mode){case HEAD:if(n.wrap===0){n.mode=TYPEDO;break}while(l<16){if(u===0)break e;u--,f+=r[s++]<<l,l+=8}if(n.wrap&2&&f===35615){n.check=0,N[0]=f&255,N[1]=f>>>8&255,n.check=crc32(n.check,N,2,0),f=0,l=0,n.mode=FLAGS;break}n.flags=0,n.head&&(n.head.done=!1);if(!(n.wrap&1)||(((f&255)<<8)+(f>>8))%31){e.msg="incorrect header check",n.mode=BAD;break}if((f&15)!==Z_DEFLATED){e.msg="unknown compression method",n.mode=BAD;break}f>>>=4,l-=4,x=(f&15)+8;if(n.wbits===0)n.wbits=x;else if(x>n.wbits){e.msg="invalid window size",n.mode=BAD;break}n.dmax=1<<x,e.adler=n.check=1,n.mode=f&512?DICTID:TYPE,f=0,l=0;break;case FLAGS:while(l<16){if(u===0)break e;u--,f+=r[s++]<<l,l+=8}n.flags=f;if((n.flags&255)!==Z_DEFLATED){e.msg="unknown compression method",n.mode=BAD;break}if(n.flags&57344){e.msg="unknown header flags set",n.mode=BAD;break}n.head&&(n.head.text=f>>8&1),n.flags&512&&(N[0]=f&255,N[1]=f>>>8&255,n.check=crc32(n.check,N,2,0)),f=0,l=0,n.mode=TIME;case TIME:while(l<32){if(u===0)break e;u--,f+=r[s++]<<l,l+=8}n.head&&(n.head.time=f),n.flags&512&&(N[0]=f&255,N[1]=f>>>8&255,N[2]=f>>>16&255,N[3]=f>>>24&255,n.check=crc32(n.check,N,4,0)),f=0,l=0,n.mode=OS;case OS:while(l<16){if(u===0)break e;u--,f+=r[s++]<<l,l+=8}n.head&&(n.head.xflags=f&255,n.head.os=f>>8),n.flags&512&&(N[0]=f&255,N[1]=f>>>8&255,n.check=crc32(n.check,N,2,0)),f=0,l=0,n.mode=EXLEN;case EXLEN:if(n.flags&1024){while(l<16){if(u===0)break e;u--,f+=r[s++]<<l,l+=8}n.length=f,n.head&&(n.head.extra_len=f),n.flags&512&&(N[0]=f&255,N[1]=f>>>8&255,n.check=crc32(n.check,N,2,0)),f=0,l=0}else n.head&&(n.head.extra=null);n.mode=EXTRA;case EXTRA:if(n.flags&1024){p=n.length,p>u&&(p=u),p&&(n.head&&(x=n.head.extra_len-n.length,n.head.extra||(n.head.extra=new Array(n.head.extra_len)),utils.arraySet(n.head.extra,r,s,p,x)),n.flags&512&&(n.check=crc32(n.check,r,p,s)),u-=p,s+=p,n.length-=p);if(n.length)break e}n.length=0,n.mode=NAME;case NAME:if(n.flags&2048){if(u===0)break e;p=0;do x=r[s+p++],n.head&&x&&n.length<65536&&(n.head.name+=String.fromCharCode(x));while(x&&p<u);n.flags&512&&(n.check=crc32(n.check,r,p,s)),u-=p,s+=p;if(x)break e}else n.head&&(n.head.name=null);n.length=0,n.mode=COMMENT;case COMMENT:if(n.flags&4096){if(u===0)break e;p=0;do x=r[s+p++],n.head&&x&&n.length<65536&&(n.head.comment+=String.fromCharCode(x));while(x&&p<u);n.flags&512&&(n.check=crc32(n.check,r,p,s)),u-=p,s+=p;if(x)break e}else n.head&&(n.head.comment=null);n.mode=HCRC;case HCRC:if(n.flags&512){while(l<16){if(u===0)break e;u--,f+=r[s++]<<l,l+=8}if(f!==(n.check&65535)){e.msg="header crc mismatch",n.mode=BAD;break}f=0,l=0}n.head&&(n.head.hcrc=n.flags>>9&1,n.head.done=!0),e.adler=n.check=0,n.mode=TYPE;break;case DICTID:while(l<32){if(u===0)break e;u--,f+=r[s++]<<l,l+=8}e.adler=n.check=ZSWAP32(f),f=0,l=0,n.mode=DICT;case DICT:if(n.havedict===0)return e.next_out=o,e.avail_out=a,e.next_in=s,e.avail_in=u,n.hold=f,n.bits=l,Z_NEED_DICT;e.adler=n.check=1,n.mode=TYPE;case TYPE:if(t===Z_BLOCK||t===Z_TREES)break e;case TYPEDO:if(n.last){f>>>=l&7,l-=l&7,n.mode=CHECK;break}while(l<3){if(u===0)break e;u--,f+=r[s++]<<l,l+=8}n.last=f&1,f>>>=1,l-=1;switch(f&3){case 0:n.mode=STORED;break;case 1:fixedtables(n),n.mode=LEN_;if(t===Z_TREES){f>>>=2,l-=2;break e}break;case 2:n.mode=TABLE;break;case 3:e.msg="invalid block type",n.mode=BAD}f>>>=2,l-=2;break;case STORED:f>>>=l&7,l-=l&7;while(l<32){if(u===0)break e;u--,f+=r[s++]<<l,l+=8}if((f&65535)!==(f>>>16^65535)){e.msg="invalid stored block lengths",n.mode=BAD;break}n.length=f&65535,f=0,l=0,n.mode=COPY_;if(t===Z_TREES)break e;case COPY_:n.mode=COPY;case COPY:p=n.length;if(p){p>u&&(p=u),p>a&&(p=a);if(p===0)break e;utils.arraySet(i,r,s,p,o),u-=p,s+=p,a-=p,o+=p,n.length-=p;break}n.mode=TYPE;break;case TABLE:while(l<14){if(u===0)break e;u--,f+=r[s++]<<l,l+=8}n.nlen=(f&31)+257,f>>>=5,l-=5,n.ndist=(f&31)+1,f>>>=5,l-=5,n.ncode=(f&15)+4,f>>>=4,l-=4;if(n.nlen>286||n.ndist>30){e.msg="too many length or distance symbols",n.mode=BAD;break}n.have=0,n.mode=LENLENS;case LENLENS:while(n.have<n.ncode){while(l<3){if(u===0)break e;u--,f+=r[s++]<<l,l+=8}n.lens[L[n.have++]]=f&7,f>>>=3,l-=3}while(n.have<19)n.lens[L[n.have++]]=0;n.lencode=n.lendyn,n.lenbits=7,C={bits:n.lenbits},T=inflate_table(CODES,n.lens,0,19,n.lencode,0,n.work,C),n.lenbits=C.bits;if(T){e.msg="invalid code lengths set",n.mode=BAD;break}n.have=0,n.mode=CODELENS;case CODELENS:while(n.have<n.nlen+n.ndist){for(;;){m=n.lencode[f&(1<<n.lenbits)-1],g=m>>>24,y=m>>>16&255,b=m&65535;if(g<=l)break;if(u===0)break e;u--,f+=r[s++]<<l,l+=8}if(b<16)f>>>=g,l-=g,n.lens[n.have++]=b;else{if(b===16){k=g+2;while(l<k){if(u===0)break e;u--,f+=r[s++]<<l,l+=8}f>>>=g,l-=g;if(n.have===0){e.msg="invalid bit length repeat",n.mode=BAD;break}x=n.lens[n.have-1],p=3+(f&3),f>>>=2,l-=2}else if(b===17){k=g+3;while(l<k){if(u===0)break e;u--,f+=r[s++]<<l,l+=8}f>>>=g,l-=g,x=0,p=3+(f&7),f>>>=3,l-=3}else{k=g+7;while(l<k){if(u===0)break e;u--,f+=r[s++]<<l,l+=8}f>>>=g,l-=g,x=0,p=11+(f&127),f>>>=7,l-=7}if(n.have+p>n.nlen+n.ndist){e.msg="invalid bit length repeat",n.mode=BAD;break}while(p--)n.lens[n.have++]=x}}if(n.mode===BAD)break;if(n.lens[256]===0){e.msg="invalid code -- missing end-of-block",n.mode=BAD;break}n.lenbits=9,C={bits:n.lenbits},T=inflate_table(LENS,n.lens,0,n.nlen,n.lencode,0,n.work,C),n.lenbits=C.bits;if(T){e.msg="invalid literal/lengths set",n.mode=BAD;break}n.distbits=6,n.distcode=n.distdyn,C={bits:n.distbits},T=inflate_table(DISTS,n.lens,n.nlen,n.ndist,n.distcode,0,n.work,C),n.distbits=C.bits;if(T){e.msg="invalid distances set",n.mode=BAD;break}n.mode=LEN_;if(t===Z_TREES)break e;case LEN_:n.mode=LEN;case LEN:if(u>=6&&a>=258){e.next_out=o,e.avail_out=a,e.next_in=s,e.avail_in=u,n.hold=f,n.bits=l,inflate_fast(e,h),o=e.next_out,i=e.output,a=e.avail_out,s=e.next_in,r=e.input,u=e.avail_in,f=n.hold,l=n.bits,n.mode===TYPE&&(n.back=-1);break}n.back=0;for(;;){m=n.lencode[f&(1<<n.lenbits)-1],g=m>>>24,y=m>>>16&255,b=m&65535;if(g<=l)break;if(u===0)break e;u--,f+=r[s++]<<l,l+=8}if(y&&(y&240)===0){w=g,E=y,S=b;for(;;){m=n.lencode[S+((f&(1<<w+E)-1)>>w)],g=m>>>24,y=m>>>16&255,b=m&65535;if(w+g<=l)break;if(u===0)break e;u--,f+=r[s++]<<l,l+=8}f>>>=w,l-=w,n.back+=w}f>>>=g,l-=g,n.back+=g,n.length=b;if(y===0){n.mode=LIT;break}if(y&32){n.back=-1,n.mode=TYPE;break}if(y&64){e.msg="invalid literal/length code",n.mode=BAD;break}n.extra=y&15,n.mode=LENEXT;case LENEXT:if(n.extra){k=n.extra;while(l<k){if(u===0)break e;u--,f+=r[s++]<<l,l+=8}n.length+=f&(1<<n.extra)-1,f>>>=n.extra,l-=n.extra,n.back+=n.extra}n.was=n.length,n.mode=DIST;case DIST:for(;;){m=n.distcode[f&(1<<n.distbits)-1],g=m>>>24,y=m>>>16&255,b=m&65535;if(g<=l)break;if(u===0)break e;u--,f+=r[s++]<<l,l+=8}if((y&240)===0){w=g,E=y,S=b;for(;;){m=n.distcode[S+((f&(1<<w+E)-1)>>w)],g=m>>>24,y=m>>>16&255,b=m&65535;if(w+g<=l)break;if(u===0)break e;u--,f+=r[s++]<<l,l+=8}f>>>=w,l-=w,n.back+=w}f>>>=g,l-=g,n.back+=g;if(y&64){e.msg="invalid distance code",n.mode=BAD;break}n.offset=b,n.extra=y&15,n.mode=DISTEXT;case DISTEXT:if(n.extra){k=n.extra;while(l<k){if(u===0)break e;u--,f+=r[s++]<<l,l+=8}n.offset+=f&(1<<n.extra)-1,f>>>=n.extra,l-=n.extra,n.back+=n.extra}if(n.offset>n.dmax){e.msg="invalid distance too far back",n.mode=BAD;break}n.mode=MATCH;case MATCH:if(a===0)break e;p=h-a;if(n.offset>p){p=n.offset-p;if(p>n.whave&&n.sane){e.msg="invalid distance too far back",n.mode=BAD;break}p>n.wnext?(p-=n.wnext,d=n.wsize-p):d=n.wnext-p,p>n.length&&(p=n.length),v=n.window}else v=i,d=o-n.offset,p=n.length;p>a&&(p=a),a-=p,n.length-=p;do i[o++]=v[d++];while(--p);n.length===0&&(n.mode=LEN);break;case LIT:if(a===0)break e;i[o++]=n.length,a--,n.mode=LEN;break;case CHECK:if(n.wrap){while(l<32){if(u===0)break e;u--,f|=r[s++]<<l,l+=8}h-=a,e.total_out+=h,n.total+=h,h&&(e.adler=n.check=n.flags?crc32(n.check,i,h,o-h):adler32(n.check,i,h,o-h)),h=a;if((n.flags?f:ZSWAP32(f))!==n.check){e.msg="incorrect data check",n.mode=BAD;break}f=0,l=0}n.mode=LENGTH;case LENGTH:if(n.wrap&&n.flags){while(l<32){if(u===0)break e;u--,f+=r[s++]<<l,l+=8}if(f!==(n.total&4294967295)){e.msg="incorrect length check",n.mode=BAD;break}f=0,l=0}n.mode=DONE;case DONE:T=Z_STREAM_END;break e;case BAD:T=Z_DATA_ERROR;break e;case MEM:return Z_MEM_ERROR;case SYNC:default:return Z_STREAM_ERROR}e.next_out=o,e.avail_out=a,e.next_in=s,e.avail_in=u,n.hold=f,n.bits=l;if(n.wsize||h!==e.avail_out&&n.mode<BAD&&(n.mode<CHECK||t!==Z_FINISH))if(updatewindow(e,e.output,e.next_out,h-e.avail_out))return n.mode=MEM,Z_MEM_ERROR;return c-=e.avail_in,h-=e.avail_out,e.total_in+=c,e.total_out+=h,n.total+=h,n.wrap&&h&&(e.adler=n.check=n.flags?crc32(n.check,i,h,e.next_out-h):adler32(n.check,i,h,e.next_out-h)),e.data_type=n.bits+(n.last?64:0)+(n.mode===TYPE?128:0)+(n.mode===LEN_||n.mode===COPY_?256:0),(c===0&&h===0||t===Z_FINISH)&&T===Z_OK&&(T=Z_BUF_ERROR),T}function inflateEnd(e){if(!e||!e.state)return Z_STREAM_ERROR;var t=e.state;return t.window&&(t.window=null),e.state=null,Z_OK}function inflateGetHeader(e,t){var n;return!e||!e.state?Z_STREAM_ERROR:(n=e.state,(n.wrap&2)===0?Z_STREAM_ERROR:(n.head=t,t.done=!1,Z_OK))}var utils=require("../utils/common"),adler32=require("./adler32"),crc32=require("./crc32"),inflate_fast=require("./inffast"),inflate_table=require("./inftrees"),CODES=0,LENS=1,DISTS=2,Z_FINISH=4,Z_BLOCK=5,Z_TREES=6,Z_OK=0,Z_STREAM_END=1,Z_NEED_DICT=2,Z_STREAM_ERROR=-2,Z_DATA_ERROR=-3,Z_MEM_ERROR=-4,Z_BUF_ERROR=-5,Z_DEFLATED=8,HEAD=1,FLAGS=2,TIME=3,OS=4,EXLEN=5,EXTRA=6,NAME=7,COMMENT=8,HCRC=9,DICTID=10,DICT=11,TYPE=12,TYPEDO=13,STORED=14,COPY_=15,COPY=16,TABLE=17,LENLENS=18,CODELENS=19,LEN_=20,LEN=21,LENEXT=22,DIST=23,DISTEXT=24,MATCH=25,LIT=26,CHECK=27,LENGTH=28,DONE=29,BAD=30,MEM=31,SYNC=32,ENOUGH_LENS=852,ENOUGH_DISTS=592,MAX_WBITS=15,DEF_WBITS=MAX_WBITS,virgin=!0,lenfix,distfix;exports.inflateReset=inflateReset,exports.inflateReset2=inflateReset2,exports.inflateResetKeep=inflateResetKeep,exports.inflateInit=inflateInit,exports.inflateInit2=inflateInit2,exports.inflate=inflate,exports.inflateEnd=inflateEnd,exports.inflateGetHeader=inflateGetHeader,exports.inflateInfo="pako inflate (from Nodeca project)";